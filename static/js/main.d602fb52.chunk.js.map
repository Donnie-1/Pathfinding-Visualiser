{"version":3,"sources":["algorithms/Dijkstra.js","Nav.js","algorithms/DFS.js","algorithms/bidirectionalBFS.js","Maze.js","Grid.js","index.js"],"names":["shortestPath","grid","startNode","endNode","colSize","rowSize","visitedNodes","distances","Array","fill","map","Infinity","prevNodes","unvisitedNodes","Set","row","col","add","flag","size","_step","minDistanceNode","minDistance","_iterator","_createForOfIteratorHelper","s","n","done","node","value","distance","err","e","f","delete","_step2","_iterator2","getNeighbors","neighbor","push","String","fromCharCode","currentNode","unshift","neighbors","isWall","Nav","props","_useState","useState","_useState2","Object","slicedToArray","selectedAlgorithm","setSelectedAlgorithm","HandleClick","event","li","target","tagName","closest","dataset","button","onClick","react_default","a","createElement","Fragment","className","Dropdown","title","items","onAlgoChange","option","data-button","window","location","reload","Ledger","_useState3","_useState4","isOpen","setIsOpen","_useState5","_useState6","setclassName","handleClick","item","handleChange","style","display","onChange","key","outline","paddingRight","background","DFS","visit","DFS_createForOfIteratorHelper","_node","filter","_ref","_ref2","r","c","getValidNeighbors","Cell","onMouseOver","updateNode","onMouseDown","onMouseUp","Grid","isVisited","isPath","setGrid","isAnimating","setIsAnimating","mazeActive","setMazeActive","nodeType","isAnimation","isHolding","newGrid","slice","concat","_useState7","_useState8","setIsHolding","handleMouseDown","handleMouseUp","resetWalls","clearPath","i","j","selectPath","algorithm","path","_shortestPath","_shortestPath2","_DFS","_DFS2","_bidirectionalShortes","midPoint","Math","floor","length","visitedNodesSource","visitedNodesEnd","distances1","distances2","unvisitedNodesStart","unvisitedNodesEnd","minDistanceNodeStart","minDistanceStart","bidirectionalBFS_createForOfIteratorHelper","minDistanceNodeEnd","minDistanceEnd","_step3","_iterator3","_step4","_iterator4","_step5","_iterator5","_step6","_iterator6","bidirectionalShortestPath","_bidirectionalShortes2","_loop","_visitedNodes$i","setTimeout","highlightVisited","_loop2","_path$i","highlightPath","alert","Nav_Nav","walls","_loop3","_walls$i","highlightWall","currentRow","visited","posIndex","random","pos","neighborRow","neighborCol","splice","generateMaze","rowIndex","cell","colIndex","ReactDOM","createRoot","document","getElementById","render","StrictMode","src_Grid"],"mappings":"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","file":"static/js/main.d602fb52.chunk.js","sourcesContent":["\nexport function shortestPath(grid, startNode, endNode, colSize, rowSize) {\n  const visitedNodes = []  \n  // Initialize the distances and previous nodes for each cell\n  const distances = Array(colSize)\n    .fill(null)\n    .map(() => Array(rowSize).fill(Infinity));\n  const prevNodes = Array(colSize)\n    .fill(null)\n    .map(() => Array(rowSize).fill(null));\n\n  // Set the distance for the start node to 0\n  distances[startNode[0]][startNode[1]] = 0;\n\n  // Initialize the unvisited nodes set\n  const unvisitedNodes = new Set();\n  for (let row = 0; row < colSize; row++) {\n    for (let col = 0; col < rowSize; col++) {\n      unvisitedNodes.add([row, col]);\n    }\n  }\n\n  let flag = true; \n  // Iterate over the unvisited nodes until all nodes have been visited\n  while (unvisitedNodes.size > 0) {\n    // Find the node with the minimum distance\n    let minDistanceNode = null;\n    let minDistance = Infinity;\n    for (const node of unvisitedNodes) {\n      const distance = distances[node[0]][node[1]];\n      if (distance < minDistance) {\n        minDistance = distance;\n        minDistanceNode = node;\n      }\n    }\n\n    // Remove the node from the unvisited nodes set\n    unvisitedNodes.delete(minDistanceNode);\n\n    // Update the distances and previous nodes for the neighboring nodes\n    if (minDistanceNode === null) {\n      break; \n    }\n\n\n    const neighbors = getNeighbors(grid, minDistanceNode, colSize, rowSize);\n    for (const neighbor of neighbors) {\n      if (neighbor[0] === endNode[0] && neighbor[1] === endNode[1]) {\n        flag = false;\n      }\n      if (flag) {\n        visitedNodes.push(neighbor);\n      }\n      \n      const distance = distances[minDistanceNode[0]][minDistanceNode[1]] + 1;\n      if (\n        distance < distances[neighbor[0]][neighbor[1]] &&\n        grid[neighbor[0]][neighbor[1]] !== String.fromCharCode(9654) \n      ) {\n        distances[neighbor[0]][neighbor[1]] = distance;\n        prevNodes[neighbor[0]][neighbor[1]] = minDistanceNode;\n      }\n    }\n  }\n\n  // Trace the shortest path from the end node to the start node\n  const shortestPath = [endNode];\n  let currentNode = endNode;\n  if (currentNode === null) { \n    return [null, visitedNodes];\n  }\n  while (currentNode[0] !== startNode[0] || currentNode[1] !== startNode[1]) {\n    currentNode = prevNodes[currentNode[0]][currentNode[1]];\n    shortestPath.unshift(currentNode);\n\n    if (currentNode === null) { \n      return [null, visitedNodes];\n    }\n  }\n  return [shortestPath, visitedNodes];\n}\n\nfunction getNeighbors(grid, node, colSize, rowSize) {\n  const neighbors = [];\n  const row = node[0];\n  const col = node[1];\n\n  if (row > 0 && grid[row - 1][col].isWall === false) {\n    neighbors.push([row - 1, col]);\n  }\n  if (row < (colSize - 1) && grid[row + 1][col].isWall === false) {\n    neighbors.push([row + 1, col]);\n  }\n  if (col > 0 && grid[row][col - 1].isWall === false){ \n    neighbors.push([row, col - 1]);\n  }\n  if (col < (rowSize - 1) && grid[row][col + 1].isWall === false) {\n    neighbors.push([row, col + 1]);\n  }\n  return neighbors;\n}","import React from 'react'\nimport { useState } from 'react';\n\nimport \"./Nav.css\"\nexport function Nav(props) {\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState('');\n\n  function handleOptionChange(option) {\n    setSelectedAlgorithm(option);\n  }\n\n  function reset() { \n    window.location.reload();\n  }\n\n  function HandleClick(event) { \n    let li = event.target;\n    if (li.tagName !== 'LI') {\n      // If the clicked element is not an li, find the closest li ancestor\n      li = li.closest('li');\n    }\n    if (li.dataset.button === '1') {\n      props.onClick(\"maze\"); \n    } else if (li.dataset.button === '2') {\n      props.onClick(selectedAlgorithm)\n    } else if (li.dataset.button === '3') {\n      props.onClick(\"ClearWalls\"); \n    }else if (li.dataset.button === '4') {\n      props.onClick(\"ClearPath\"); \n    }\n  }\n\n  return (\n    <>\n      <div className='nav-bar'>\n      <div className='header'>Path Finder Visualiser</div>\n\n      <Dropdown className='nav-item' title=\"Algorithms\" items={[\"Dijkstra\", 'DFS', 'Bi-Directional BFS']} \n      selectedAlgorithm={selectedAlgorithm} onAlgoChange={handleOptionChange} />\n      \n        <li \n          className='nav-item gen'\n          data-button=\"1\"\n          onClick={HandleClick}>\n            Generate Random Maze\n        </li>\n          \n          <li \n            className='nav-item play-button'\n            data-button=\"2\"\n            onClick={HandleClick}>\n              Visualise {selectedAlgorithm}\n          </li>\n          \n\n          <li \n            className='nav-item'\n            onClick={reset}>\n            Reset\n          </li>\n\n          <li \n          className='nav-item'\n          data-button=\"3\"\n          onClick={HandleClick}> \n          Clear Walls\n        </li>\n\n        <li \n          className='nav-item'\n          data-button=\"4\"\n          onClick={HandleClick}\n          >Clear Path\n        </li> \n\n    </div>\n    <Ledger/>\n    </>\n  )\n}\n\nfunction Dropdown(props) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [className, setclassName] = useState(\"nav-item nav-link\");\n\n  function handleClick(item) {\n\n    setIsOpen(!isOpen);\n    setclassName(isOpen ? \"nav-item nav-link\" : \"nav-active\");\n  }\n\n  function handleChange(item) {\n    props.onAlgoChange(item);\n  }\n\n  return (\n    <li onClick={handleClick}>\n      <div className={className}>{props.title} \n        <span className='arrow'></span>\n      </div>\n      {isOpen && (\n        <div \n          className=\"dropdown-content\" \n          style={{display: 'flex'}}\n          value={props.selectedAlgorithm} \n          onChange={handleChange}\n        >\n\n          {props.items.map(item => (\n            <div \n              className=\"drop-item\" \n              onClick={ () => {handleClick(item); handleChange(item)}} \n              value={item}\n              key={item}>\n              {item}\n            </div>\n          ))}\n        </div>\n      )}\n    </li>\n  );\n}\n\nfunction Ledger() { \n  return (\n    <div className='ledger'>\n      <div className='ledger-item'> \n      <div className='startNode' style={{outline: \"none\", paddingRight: \"5px\"}}></div>\n      Start node </div>\n      <div className='ledger-item'> \n      <div className='endNode' style={{outline: \"none\", paddingRight: \"5px\"}}></div>\n      End node </div>\n      <div className='ledger-item'>\n        <div className='ledger-wall'></div>\n        Wall</div>\n      <div className='ledger-item'>\n        <div className='ledger-wall' style={{background: \"#C274FD\"}}></div>\n        Visited</div>\n      <div className='ledger-item'>\n        <div className='ledger-wall' style={{background: \"yellow\"}}></div>\n        Path</div>\n    </div>\n  )\n}","export function DFS(grid, startNode, endNode, colSize, rowSize) {\n    const visitedNodes = []  \n  \n    // Initialize the unvisited nodes set\n    const unvisitedNodes = [[]];\n    for (let row = 0; row < colSize; row++) {\n      for (let col = 0; col < rowSize; col++) {\n        unvisitedNodes.push([row, col]);\n      }\n    }\n  \n    // Recursive function that visits all nodes reachable from the given node\n    function visit(node) {\n      // Add the node to the visited nodes list\n      visitedNodes.push([node[0],node[1]]);\n  \n      // If the node is the end node, stop the search\n      if (node[0] === endNode[0] && node[1] === endNode[1]) {\n        return true;\n      }\n  \n      // Remove the node from the unvisited nodes set\n      unvisitedNodes[node[0]][node[1]] = \"X\";\n  \n      // Visit all the reachable neighboring nodes\n      const neighbors = getNeighbors(grid, node, colSize, rowSize);\n      for (const neighbor of neighbors) {\n        if (unvisitedNodes[neighbor[0]][neighbor[1]] !== \"X\" && \n        grid[neighbor[0]][neighbor[1]] !== String.fromCharCode(9726)) {\n          if (visit(neighbor)) {\n            return true;\n          }\n          \n        } \n      }\n      // If the end node is not reachable from this node, return false\n\n      return false;\n    }\n  \n    // Start the search from the start node\n    visit(startNode);\n\n    return [visitedNodes, visitedNodes];\n  }\n  function getNeighbors(grid, node, colSize, rowSize) {\n    const neighbors = [];\n    const [row, col] = node;\n    if (row > 0) neighbors.push([row - 1, col]);\n    if (row < colSize - 1) neighbors.push([row + 1, col]);\n    if (col > 0) neighbors.push([row, col - 1]);\n    if (col < rowSize - 1) neighbors.push([row, col + 1]);\n    return neighbors.filter(([r, c]) => grid[r][c].isWall === false);\n  }","import {shortestPath} from './Dijkstra.js'; \n\nexport function bidirectionalShortestPath(grid, startNode, endNode, colSize, rowSize, mazeActive) {\n    const arr = shortestPath(grid, startNode, endNode, colSize, rowSize);\n    const path = arr[0]; \n    const midPoint = path[Math.floor(path.length/2)];\n    const visitedNodes = []  \n    const visitedNodesSource = []\n    const visitedNodesEnd = []\n\n  // Initialize the distances and previous nodes for each cell\n  const distances1 = Array(colSize)\n    .fill(null)\n    .map(() => Array(rowSize).fill(Infinity));\n    \n\n  const distances2 = Array(colSize)\n    .fill(null)\n    .map(() => Array(rowSize).fill(Infinity));\n\n  // Set the distance for the start and end nodes to 0\n  distances1[startNode[0]][startNode[1]] = 0;\n  distances2[endNode[0]][endNode[1]] = 0;\n\n  // Initialize the unvisited nodes sets for both the forward and backward searches\n  const unvisitedNodesStart = new Set();\n  const unvisitedNodesEnd = new Set();\n  for (let row = 0; row < colSize; row++) {\n    for (let col = 0; col < rowSize; col++) {\n      unvisitedNodesStart.add([row, col]);\n      unvisitedNodesEnd.add([row, col]);\n    }\n  }\n  \n  // Iterate over the unvisited nodes until all nodes have been visited or the search meets in the middle\n  while (unvisitedNodesStart.size > 0 && unvisitedNodesEnd.size > 0) {\n    // Find the node with the minimum distance for the forward search\n    let minDistanceNodeStart = null;\n    let minDistanceStart = Infinity;\n    for (const node of unvisitedNodesStart) {\n      const distance = distances1[node[0]][node[1]];\n      if (distance < minDistanceStart) {\n        minDistanceStart = distance;\n        minDistanceNodeStart = node;\n      }\n    }\n\n\n    // Find the node with the minimum distance for the backward search\n    let minDistanceNodeEnd = null;\n    let minDistanceEnd = Infinity;\n    for (const node of unvisitedNodesEnd) {\n      const distance = distances2[node[0]][node[1]];\n      if (distance < minDistanceEnd) {\n        minDistanceEnd = distance;\n        minDistanceNodeEnd = node;\n      }\n    }\n    \n    if ( minDistanceNodeEnd === null || minDistanceNodeStart === null) {\n        break; \n    }\n      // Remove the nodes from the unvisited nodes sets\n    unvisitedNodesStart.delete(minDistanceNodeStart);\n    unvisitedNodesEnd.delete(minDistanceNodeEnd);\n   \n\n    if (mazeActive) { \n      for(let i of visitedNodesSource) { \n        for(let j of visitedNodesEnd) { \n          if (i[0] === j[0] && i[1] === j[1]) {\n            return [path, visitedNodes]\n          } \n        }\n      }\n    }\n\n    //   Update the distances and previous nodes for the neighboring nodes in the forward search\n      const neighborsStart = getNeighbors(grid, minDistanceNodeStart, colSize, rowSize);\n      for (const neighbor of neighborsStart) {\n        if (neighbor[0] === endNode[0] && neighbor[1] === endNode[1]) {\n            continue;\n        }\n\n        visitedNodesSource.push(neighbor);\n        visitedNodes.push(neighbor);\n\n  \n\n        const distance = distances1[minDistanceNodeStart[0]][minDistanceNodeStart[1]] + 1;\n        if (\n          distance < distances1[neighbor[0]][neighbor[1]] &&\n          grid[neighbor[0]][neighbor[1]] !== String.fromCharCode(9654) \n        ) {\n          distances1[neighbor[0]][neighbor[1]] = distance;\n        }\n      }\n\n\n      \n      // Update the distances and previous nodes for the neighboring nodes in the backward search\n      if (minDistanceNodeEnd === null) {\n        break; \n      }\n      const neighborsEnd = getNeighbors(grid, minDistanceNodeEnd, colSize, rowSize);\n      for (const neighbor of neighborsEnd) {\n        if (neighbor[0] === endNode[0] && neighbor[1] === endNode[1]) {\n            continue;\n        }\n\n        visitedNodesEnd.push(neighbor);\n        visitedNodes.push(neighbor);\n\n\n        if (neighbor[0] === midPoint[0] && neighbor[1] === midPoint[1] && mazeActive === false) { \n          return [path, visitedNodes]\n        }\n\n        const distance = distances2[minDistanceNodeEnd[0]][minDistanceNodeEnd[1]] + 1;\n        if (\n          distance < distances2[neighbor[0]][neighbor[1]] &&\n          grid[neighbor[0]][neighbor[1]] !== String.fromCharCode(9726) \n        ) {\n          distances2[neighbor[0]][neighbor[1]] = distance;\n        }\n      }\n    }\n    return [path, visitedNodes]\n}\n    \n\nfunction getNeighbors(grid, node, colSize, rowSize) {\n    const neighbors = [];\n    const row = node[0];\n    const col = node[1];\n    \n    if (row > 0 && (grid[row - 1][col].isWall === false)) {\n        neighbors.push([row - 1, col]);\n    }\n    if (row < (colSize - 1) && (grid[row + 1][col].isWall === false)) {\n        neighbors.push([row + 1, col]);\n    }\n    if (col > 0 && (grid[row][col - 1].isWall === false)){ \n        neighbors.push([row, col - 1]);\n    }\n    if (col < (rowSize - 1) && (grid[row][col + 1].isWall === false) ) {\n        neighbors.push([row, col + 1]);\n    }\n    return neighbors;\n    }","export function generateMaze(rowSize, colSize) {\n  let grid = [];\n  for (let row = 0; row < rowSize; row++) {\n    let currentRow = [];\n    for (let col = 0; col < colSize; col++) {\n      currentRow.push(1);\n    }\n    grid.push(currentRow);\n  }\n  \n  let startRow = 10\n  let startCol = 10\n  \n  grid[startRow][startCol] = 0;\n  \n  let visited = [[startRow, startCol]];\n  \n  while (visited.length > 0) {\n    let posIndex = Math.floor(Math.random() * visited.length);\n    let pos = visited[posIndex];\n    let row = pos[0];\n    let col = pos[1];\n    \n    let neighbors = getValidNeighbors(grid, row, col, rowSize, colSize);\n    \n    if (neighbors.length > 0) {\n      let neighborIndex = Math.floor(Math.random() * neighbors.length);\n      let neighbor = neighbors[neighborIndex];\n      let neighborRow = neighbor[0];\n      let neighborCol = neighbor[1];\n      \n      grid[(row + neighborRow) / 2][(col + neighborCol) / 2] = 0;\n      \n      grid[neighborRow][neighborCol] = 0;\n      visited.push([neighborRow, neighborCol]);\n    } else {\n      visited.splice(posIndex, 1);\n    }\n  }\n\n  let walls = [];\n  for (let row = 0; row < rowSize; row++) {\n    for (let col = 0; col < colSize; col++) {\n      if (grid[row][col] === 1) {\n        walls.push([row, col]);\n      }\n    }\n  }\n  return walls;\n}\n\nfunction getValidNeighbors(grid, row, col, rowSize, colSize) {\n  let neighbors = [];\n  if (row > 1 && grid[row - 2][col] === 1) {\n    neighbors.push([row - 2, col]);\n  }\n  if (row < rowSize - 2 && grid[row + 2][col] === 1) {\n    neighbors.push([row + 2, col]);\n  }\n  if (col > 1 && grid[row][col - 2] === 1) {\n    neighbors.push([row, col - 2]);\n  }\n  if (col < colSize - 2 && grid[row][col + 2] === 1) {\n    neighbors.push([row, col + 2]);\n  }\n  return neighbors;\n}","import React, { useState }  from 'react';\nimport \"./Grid.css\"; \nimport {shortestPath} from './algorithms/Dijkstra.js'; \nimport {Nav} from './Nav.js'; \nimport {DFS} from './algorithms/DFS.js';\nimport {bidirectionalShortestPath} from './algorithms/bidirectionalBFS.js';\nimport {generateMaze} from './Maze.js';\n\n\nfunction Cell (props) {\n  let value = false;\n  let className = \"cell\";\n  // Set start\n  if (props.row === props.startNode[0] && props.col === props.startNode[1]) {\n    value =  true;\n    className = \"startNode\"\n  }\n\n  // Set end\n  if (props.row === props.endNode[0] && props.col === props.endNode[1]) {\n    value =  true; \n    className = \"endNode\"\n  }\n\n  return (\n  \n  <div\n      style={props.style}\n      className={value ? className : props.className}                                      // isWall, isVisited, isPath\n      onMouseOver={() => { props.updateNode(props.row, props.col, \"wall\", [true, false, false], false) }}\n      onMouseDown={props.onMouseDown}\n      onMouseUp={ props.onMouseUp}\n    >\n      {value}\n    </div>\n  );\n};\n\nfunction Grid() {\n  const rowSize = 60; \n  const colSize = 60;\n  const startNode = [39, 30];\n  const endNode = [47, 30];\n\n  const [grid, setGrid] = useState(() => {\n    return Array(colSize)\n      .fill(null)\n      .map(() => Array(rowSize).fill({ \n        value: '', \n        style: {}, \n        className: 'cell', \n        isWall: false, \n        isVisited: false, \n        isPath: false,\n      }));\n  });\n\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [mazeActive, setMazeActive] = useState(false);\n\n  function updateNode(row, col, className, nodeType, isAnimation) {\n    if  ((row === startNode[0] && col === startNode[1]) || \n        (row === endNode[0] && col === endNode[1])) {\n      return; \n    }\n    if (isHolding && isAnimating) {\n      return; \n    }\n\n    if (isHolding || isAnimation) {  \n      setGrid(() => {\n        const newGrid = grid.slice();\n        newGrid[row][col] = {\n          className: `${className}`,\n          isWall: nodeType[0],\n          isVisited: nodeType[1], \n          isPath: nodeType[2], \n        };\n        return newGrid;\n      });\n    }\n  };\n\n  // Click and hold event for wall placement\n  const [isHolding, setIsHolding] = useState(false);\n  function handleMouseDown() {\n    setIsHolding(true);\n  }\n\n  function handleMouseUp() {\n    setIsHolding(false);\n  }\n\n  // Highlight algorithm process \n  function highlightVisited(visitedNodes) { \n    resetWalls(true);\n    setIsAnimating(true);\n\n    for (let i = 0; i < visitedNodes.length; i++) {\n      const [row, col] = visitedNodes[i];\n\n      setTimeout(() => {\n        updateNode(row, col, \"visitedPath visitedNodePurple\", [false, true, false], true);\n      }, 5*i);\n\n      setTimeout(() => {\n        setIsAnimating(false);\n      }, visitedNodes.length * 5);\n    }\n\n  }\n\n  // Highlight (shortest) path\n  function highlightPath(path) { \n    for (let i = 0; i < path.length; i++) {\n      const [row, col] = path[i];\n  \n      setTimeout(() => {\n        updateNode(row, col, \"path\", [false, true, true], true);\n          \n      }, 20 * i);\n    }\n  }\n\n  function highlightWall(walls) {\n    if (isAnimating) {\n      return\n    }\n\n    setMazeActive(true);\n    resetWalls(false);\n    setIsAnimating(true);\n    \n    for (let i = 0; i < walls.length; i++) {\n      const [row, col] = walls[i];\n      if (row >= rowSize || col >= colSize) {\n        continue;\n      }\n\n      setTimeout(() => {\n        updateNode(row, col, \"maze wall\", [true, false, false], true);\n      }, 2*i);\n\n      setTimeout(() => {\n        setIsAnimating(false);\n      }, walls.length * 2);\n\n    }\n  }\n\n  function resetWalls(clearPath) { \n\n    for (let i = 0; i < rowSize; i++) {\n      for (let j = 0; j < colSize; j++) {\n        if (clearPath) { \n          if (grid[i][j].isPath || grid[i][j].isVisited) {  \n            updateNode(i, j, \"cell\", [false, true, false], true);\n          }\n        } else if (grid[i][j].isWall && clearPath === false) {\n          setMazeActive(false);\n          updateNode(i, j, \"cell\", [false, true, false], true);\n        }\n      }\n    }\n  }\n  \n  function selectPath(algorithm) {\n    if(isAnimating) {\n      return \n    }\n    let visitedNodes = []; \n    let path = []; \n    if (algorithm === \"Dijkstra\") {\n      [path, visitedNodes] = shortestPath(grid, startNode, endNode, colSize, rowSize);\n    } else if (algorithm === \"DFS\") {\n      [path, visitedNodes] = DFS(grid, startNode, endNode, colSize, rowSize);\n    } else if (algorithm === \"Bi-Directional BFS\") {\n      [path, visitedNodes] = bidirectionalShortestPath(grid, startNode, endNode, colSize, rowSize, mazeActive); \n    }\n\n    if (path === null){\n      alert(\"No path found\");\n      return;\n    }\n\n    highlightVisited(visitedNodes);\n    setTimeout(() => {\n      highlightPath(path);\n    }, (visitedNodes.length) * 5);\n  }\n\n  function handleClick(event) {\n    if (event.length === 0) { \n      alert(\"Select an Algorithm! \");\n    } else if (event === \"maze\") {  \n      resetWalls(true);\n      let visitedNodes = generateMaze(rowSize, colSize);\n      highlightWall(visitedNodes);\n    } else if (event === \"ClearWalls\") {\n      resetWalls(false);\n    } else if (event === \"ClearPath\") {\n      resetWalls(true);\n    } else { \n      selectPath(event); \n    }\n  }\n\n  return (\n    <>\n    <Nav onClick={handleClick} />\n    <div className ='grid-parent'>\n      <div className = 'grid'>\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex}>\n            {row.map((cell, colIndex) => (\n\n              <Cell\n                key={colIndex}\n                row={rowIndex}\n                col={colIndex}\n                startNode={startNode}\n                endNode={endNode}\n                value={cell.value}\n                style={cell.style}\n                className={cell.className}\n                updateNode={updateNode}\n                onMouseDown={handleMouseDown}\n                onMouseUp={handleMouseUp}\n              />\n\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n    </>\n  );\n};\n\nexport default Grid;","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport Grid from './Grid';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <Grid />\n\n  </React.StrictMode>\n);\n\n"],"sourceRoot":""}